---
title: '[Algorithm] 문자열 찾기, 작성 중'
toc: true
toc-stick: true
search: true
categories:
  - algorithm
tags:
  - algorithm
  - KMP Algorithm
  - Suffix Array
---

주어진 문자열 더미(Haystack)속에, 특정 문자열(Needle)이 존재하는지 찾는 알고리즘.
만약, 'avava'에서 'ava'를 찾는다면 0과 2를 반환한다.

## Naive algorithm  
가장 쉬운 방법은 모든 인덱스에서 직접 비교해보며 탐색하는 방법이다.

``` cpp
vector<int> naiveSearch(const string& H, const string& N){
    vector<int> ret;

    for(int begin = 0 ; begin + N.size() <= H.size() ; ++begin){
        bool matched = true;
        for(int i = 0 ; i < N.size() ; i++){
            if(N[i] != H[begin + i]){
                matched = false;
                break;
            }
        }

        if(matched) ret.push_back(begin);
    }

    return ret;
}
```

이 방법은 특정 입력에 대해 비효율적으로 동작한다.
만약, H와 N이 하나의 알파벳으로 구성된 긴 문자열이라면 가능한 모든 위치가 답이 되고
수행 시간은 O(|N| * |H|)가 된다.  
C++의 find, JAVA의 indexOf 등이 이 알고리즘을 사용한다.


## KMP Algorithm

|Index|0|1|2|3|4|5|6|7|8|9|10|
|N|a|b|b|a|a|a|b|a|b|a|
|H|a|b|a||||||||

만약 이와 같은 비교를 한다고 하면, 순차적으로
H[0 ~ 1]과 N[0 ~ 1]가 일치하는 것을 확인하였으나 H[2]와 N[2]가 다르기 때문에 다음 탐색으로 넘어가게 된다.

하지만 H의 시작이 'a'이라는 것을 알고, N[1]이 'b'라는 것을 탐색한 적이 있는데 굳이 1번 인덱스부터 탐색을 해야될까? 
이처럼 KMP 알고리즘은 문자열 비교 과정에서 얻은 정보로 불필요한 부분의 탐색을 줄인다.  

**다음 탐색 위치 찾기**  

|Index|...|i|i+1|i+2|i+3|i+4|i+5|
|H|...|a|b|c|a|b|d|a|b|c|
|N|...|a|b|c|a|b|c|
|N|...||||a|b|c|a|b|c|
